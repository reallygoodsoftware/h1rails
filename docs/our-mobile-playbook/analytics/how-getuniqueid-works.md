---
icon: circle-small
---

# How getUniqueId works

> This document was largely generated by Claude, which is why it reads a bit weirdly.&#x20;

When building React Native apps, developers often need a way to uniquely identify devices for analytics, user tracking, or other purposes. The `react-native-device-info` library provides a `getUniqueId()` method that seems perfect for this, but understanding what it actually returns is crucial for making informed decisions about user identification.

### What DeviceInfo.getUniqueId() Actually Returns

Contrary to what the name might suggest, `getUniqueId()` does **not** return a hardware-based device identifier. Instead, it returns platform-specific system-generated IDs that have important limitations and behaviors you need to understand.

#### iOS: identifierForVendor (IDFV)

On iOS, `getUniqueId()` returns the `identifierForVendor` (IDFV), which is:

* A UUID generated by iOS that's unique to each combination of vendor and device
* **Not** tied to device hardware - it's a software-generated identifier
* Shared across all apps from the same vendor on the same device
* Completely different from the deprecated iOS UDID (Unique Device Identifier)

#### Android: ANDROID\_ID

On Android, the method returns `Settings.Secure.ANDROID_ID`, which is:

* A 64-bit hex string generated by the Android system
* Unique to each combination of app signing key, user, and device
* **Not** a hardware serial number or MAC address
* Generated fresh on each device setup

### How "Vendor" is Determined (iOS)

This is where it gets interesting. Apple determines the vendor based on your app's **bundle identifier**, not your App Store publisher account.

Specifically, Apple looks at the first two components of your bundle ID:

```
com.yourcompany.fitness-app    → Vendor: com.yourcompany
com.yourcompany.recipe-app     → Vendor: com.yourcompany (same!)
com.yourcompany.news-reader    → Vendor: com.yourcompany (same!)
com.different.other-app        → Vendor: com.different (different)
```

This means if you publish multiple apps with the same bundle ID prefix, they'll all receive the same IDFV for any given user.

### Cross-App Identification Within Your App Suite

Because of the vendor-based system on iOS, you can actually track users across multiple apps you've published:

```javascript
// In your fitness app (com.yourcompany.fitness)
const idfv = await DeviceInfo.getUniqueId();
// Returns: "12345678-1234-1234-1234-123456789012"

// In your recipes app (com.yourcompany.recipes)
const idfv = await DeviceInfo.getUniqueId();
// Returns: "12345678-1234-1234-1234-123456789012" (identical!)
```

On Android, since the ID is tied to the app signing key, you'll get the same behavior if you sign all your apps with the same key.

### When the ID Changes or Resets

#### iOS IDFV Reset Conditions

The IDFV gets reset to a completely new value when:

1. **All apps from the vendor are uninstalled**: If a user uninstalls every single app you've published, the IDFV is cleared
2. **Device restore**: When restoring to a new device, the IDFV changes
3. **Factory reset**: Obviously, this clears everything

Important: The IDFV does **not** reset when just one app is uninstalled, as long as other apps from the same vendor remain installed.

#### Android ANDROID\_ID Reset Conditions

The Android ID resets when:

1. **Factory reset**: Complete device wipe
2. **Different app signing key**: If you change how you sign your app
3. **Different user profile**: Android's multi-user support can affect this

### Privacy and Hardware Access Limitations

Both platforms have moved away from providing access to true hardware identifiers due to privacy concerns:

* **iOS**: Deprecated UDID access years ago and restricts access to hardware serials
* **Android**: Restricted access to hardware serials, MAC addresses, and other permanent identifiers

The IDs returned by `getUniqueId()` are specifically designed to provide app developers with identification capabilities while preserving user privacy through resettable, software-generated identifiers.

### Not the Same as iOS UDID

It's important to note that iOS's IDFV is completely different from the old UDID (Unique Device Identifier):

* **UDID**: Was a permanent, hardware-tied identifier that never changed
* **IDFV**: Is a software-generated identifier that can reset under certain conditions
* **UDID**: Was deprecated and removed due to privacy concerns
* **IDFV**: Was introduced as a privacy-friendly alternative

### Practical Implications for Your App

Understanding these behaviors helps you make better decisions:

**Good for:**

* Analytics tracking during normal app usage
* Cross-app user identification within your app suite
* Session management and user preferences

**Not reliable for:**

* Permanent device fingerprinting
* Critical user identification that must survive app uninstalls
* Hardware-based device authentication

**Alternative approach:** For installation-specific tracking that doesn't need to survive uninstalls, generating and storing your own UUID might be simpler and more predictable than relying on system-provided identifiers with complex reset behaviors.

### Code Example

```javascript
import DeviceInfo from 'react-native-device-info';

const getDeviceIdentifier = async () => {
  try {
    const uniqueId = await DeviceInfo.getUniqueId();
    console.log('Device Unique ID:', uniqueId);
    
    // iOS: "12345678-1234-1234-1234-123456789012" (IDFV format)
    // Android: "9774d56d682e549c" (64-bit hex string)
    
    return uniqueId;
  } catch (error) {
    console.error('Error getting unique ID:', error);
    return null;
  }
};
```

By understanding exactly what `getUniqueId()` returns
